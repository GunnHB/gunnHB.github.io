---
title:  "[Unreal Lecture 001] Section001::플레이어 연결하기 002"
excerpt: ""

author: gunnHB
categories: 
 - UnrealLecture
tags: 
 - [Github, Git, Unreal, Programming, UnrealLecture, C++]

toc: true
toc_sticky: true
 
date: 2024-09-23
last_modified_at: 2024-09-23
---

🔔 유데미 [언리얼 C++ 멀티플레이어 마스터 : 중급 게임 개발](https://www.udemy.com/course/best-unreal-c/?couponCode=ST22MT92324B)을 정리한 내용입니다. 🔔
{: .notice}

## 움직이는 플랫폼 만들기
프로젝트에 움직이는 플랫폼을 하나 추가해봅시다. 이는 `StaticMeshActor`를 이용해 추가할 수 있습니다. 이는 C++클래스 추가 창의 모든 클래스에서 검색을 통해 추가할 수 있습니다.

이동하는 플랫폼이기 때문에 해당 `Tick`함수를 이용해 이동을 구현하면 됩니다.

```c++
// .h

UCLASS()
class PUZZELPLATFORM_API AMovingPlatform : public AStaticMeshActor
{
	GENERATED_BODY()

public:
	AMovingPlatform();
	
protected:
    virtual void Tick(float DeltaSeconds) override;
};
```

```c++
// .cpp

AMovingPlatform::AMovingPlatform()
{
	// Tick을 활성화
	PrimaryActorTick.bCanEverTick = true;

	// 매시 에셋 가져오기
	static ConstructorHelpers::FObjectFinder<UStaticMesh> mesh(TEXT("/Script/Engine.StaticMesh'/Engine/EngineMeshes/Cube.Cube'"));

	// 메시 세팅
	if(mesh.Succeeded())
		GetStaticMeshComponent()->SetStaticMesh(mesh.Object);

	// 크기 세팅
	GetStaticMeshComponent()->SetRelativeScale3D(FVector(.7f, .7f, .1f));

	// 무버를로 설정해주지 않으면 에러가 출력
	SetMobility(EComponentMobility::Movable);
}

void AMovingPlatform::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	FVector location = GetActorLocation();
	// 초당 5cm씩 이동시키기 위해
	location += FVector(5.f * DeltaSeconds, 0.f, 0.f);
	SetActorLocation(location);
}
```

AMovingPlatform 함수에서 SetMobility 함수를 호출하는데, 이는 플레이 중 액터가 어떤 방식으로 이동 또는 변화할 수 있도록 할지 제어하는 세팅입니다.

- Static
	- 플레이 도중 어떤 식으로든 이동 또는 변화할 수 없는 액터
- Stationary
	- 플레이 도중 이동하지는 못하지만 변할 수는 있는 액터
- Movable
	- 플레이 도중 추가, 제거, 이동해야 하는 액터

컴파일 후 적당한 위치에 배치하고 플레이를 해보면 굉장히 천천히 X축으로 이동하는 큐브를 확인할 수 있습니다.

![2024-09-24142326-ezgif com-video-to-gif-converter](https://github.com/user-attachments/assets/bf2ad774-91ef-4407-a8e1-984903251aa4)

## 클라이언트? 서버?
그런데 우리가 플레이하는 환경이 클라이언트와 서버 중 무엇일까요? 데디케이티드 서버의 경우 전용 서버가 존재하지 않기 때문에 누가 서버이고 누가 클라이언트인지 확인하기 어렵습니다.

우선 작성한 코드는 서버와 클라이언트 모두 사용한다는 점을 알아야합니다. 누군가 서버의 역할을 한다면 해당 서버에 다른 유저가 접속하는 형태인 것입니다.

이를 구분하기 위해 언리얼에서는 `HasAuthority()` 함수를 제공해줍니다. 이는 해당 <u>유저가 서버라면 true</u>를 <u>클라이언트라면 false</u>를 반환하는 함수입니다.

이를 이용해 위 코드를 조금 수정해보면 다음과 같습니다.

```c++
// .cpp

void AMovingPlatform::Tick(float DeltaSeconds)
{
	Super::Tick(DeltaSeconds);

	// 주체가 서버인지
	if(HasAuthority())
	{
		FVector location = GetActorLocation();
		// 초당 5cm씩 이동시키기 위해
		location += FVector(5.f * DeltaSeconds, 0.f, 0.f);
		SetActorLocation(location);
	}
}
```

HasAuthority() 함수는 Actor에 위치해 있습니다.
{: .notice--info}

이렇게 해서 플레이를 해보면 서버인 유저의 화면에서는 큐브가 움직이지만 클라이언트 유저의 화면에서는 움직이지 않는 것을 확인할 수 있습니다.

![2024-09-24144703-ezgif com-video-to-gif-converter](https://github.com/user-attachments/assets/11ee08be-33ca-4ef9-a258-81c8e89bf5b4)

## 마무리
이번 포스팅에서는 MovingPlatform의 생성과 Tick 함수를 이용한 액터의 이동, HasAuthority 함수의 역할에 대해 알아보았습니다.😊