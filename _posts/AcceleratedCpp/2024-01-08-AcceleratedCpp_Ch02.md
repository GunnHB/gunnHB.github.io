---
title:  "[Accelerated C++] 002. 반복문과 카운팅"
excerpt: "C++에서의 반복문을 알아봅시다!"

author: gunnHB
categories: 
 - Accelerated Cpp
tags: 
 - [Github, Git, Programming, CPP, Accelerated Cpp]

toc: true
toc_sticky: true
 
date: 2024-01-08
last_modified_at: 2024-01-11
---

🔔 \[AcceleratedC++\] 서적을 정리한 내용입니다. 🔔
{: .notice}

<div class="notice--info" markdown="1">
이전 포스팅에서 테두리로 둘러쌓인 인사말을 출력하는 프로그램을 만들었습니다.
이번 포스팅에서는 반복문을 통해 사용자가 테두리의 크기를 변경할 수 있는
프로그램을 만들어봅시다.
</div>

## 해결해야 하는 문제
```c++
****************
*              *
* Hello, noob! *
*              *
****************
```

위 출력문은 이전 포스팅에서 출력했던 테두리로 둘러쌓인 인사말의 결과입니다.
해당 결과를 출력하는 프로그램은 한 번에 한 행씩 출력합니다.

위 프로그램의 방식은 아주 큰 단점이 있습니다. **<u>각 행의 간단한 수정이 필요할 때마다
프로그램을 새롭게 만들어야한다는 점</u>**입니다. 그렇기에 이번에는 각 행을 변수에 저장하지 않는
출력 형식으로 만들어봅시다. 

## 전체적인 구조
```c++
// 이름을 입력받아 테두리로 묶인 인사말을 생성
#include <iostream>
#include <string>

int main() 
{
  // 이름을 물음
  std::cout << "Please enter your name: ";

  // 이름을 입력
  std::string name;
  std::cin >> name;

  // 출력하려는 메시지를 구성
  const std::string greating = "Hello, " + name + "!";

  // 다시 작성할 부분
  return 0;
}
```

위의 스크립트는 이전 스크립트와 동일하여 다시 작성하지 않아도 되는 부분입니다.
새로운 프로그램에 필요한 부분을 하나씩 구현하여 완성시켜봅시다.

## 주어진 개수만큼 행 출력하기
인사말과 위아래 테두리는 각각 한 행을 차지하므로 행의 개수는 총 3개입니다. 여기에
인사말과 한 쪽 테두리 사이에 남겨 둘 공백 개수의 2배를 더한 것으로 행의 총 개수를 구할 수 있습니다.

```c++
// 인사말과 한 쪽 테두리 사이의 공백 개수
const int pad = 1;

// 출력할 행의 전체 개수
const int rows = pad * 2 + 3;
```

- `pad` : 인사말과 한 쪽 테두리 사이의 공백 개수를 저장하는 상수
- `row` : pad를 사용하여 출력하고자 하는 행의 전체 개수를 제어

두 값은 const를 이용해 정의되었으므로 상수입니다.
{: .notice--warning}

pad 값의 변경만으로 공백 개수가 변경되어 행의 개수 역시 변경됩니다.

### while문
```c++
// 입력과 출력을 구분
std::cout << std::endl;

// rows만큼의 행을 출력
int r = 0;

// 불변성 : 지금까지 r개 행을 출력
while (r != rows)
{
    // 하나의 행을 출력
    std::cout << std::endl;
    ++r;
}
```

위 스크립트에서 while문을 이용하여 출력할 행의 개수를 제어합니다. 

- `while` : 주어진 조건이 참일 때 실행문을 반복

```c++
while (조건)
    실행문
```

'실행문'을 while문의 `본문body`이라고도 합니다.

while문은 조건을 판별하는 것으로 시작합니다. 조건이 거짓이면 본문을 전혀 실행하지 않습니다.
반면에 조건이 참이면 본문을 한 번 싥행한 후 다시 조건을 판별합니다. while문은 조건이 거짓일 때까지
조건 판별 및 본문 실행을 반복합니다.

가독성을 위하여 실행문을 다음 행에 들여쓰기했지만 한 줄에 작성해도 됩니다. 
<br>다만 이렇게 작성했을 때 다른 사람들이 해당 스크립트를 봤을 때 해석에 어려움을 겪을 수 있다는 점을 염두에 둡시다.
{: .notice--warning}

위 스크립트의 while문 조건은 `비항등 연산자inequality operator`인 !=를 사용하여 r과 rows를 비교합니다.
해당 표현식의 결과는 bool 타입입니다.

```c++
++r;
```

++는 `증가increment 연산자`이고 변수 r 값을 1만큼 증가시킵니다.

### while문 설계하기
while문을 작성하고 이해하는 데 유용한 두 가지 주요 개념을 살펴보도록 합시다.

- while문의 정의
- 일반적인 프로그램의 동작

첫 번째는 while문이 종료할 때 조건은 반드시 거짓이어야 하는 것이고, 두 번째는 while문 내부에서 항상 참인
`루프 불변성loop invariant`입니다.

의도한대로 프로그램이 동작할 수 있게 불변성을 정해야 하고 적절한 때 불변성이 참이 되도록 프로그램을 작성해야 합니다.

우리는 while문의 불변성의 참을 검증하기 위해 두 가지를 확인해야 합니다.

- while문이 처음으로 조건을 판별하기 바로 전
  - 조건에 맞는가를 확인하여 본문을 호출시킵니다.

- while문의 본문이 끝나기 바로 전
  - 해당 지점에서 불변성이 참이라면 이후 조건 판별 역시 참입니다.

지금까지의 것들을 정리하면 다음과 같습니다.

```c++
//불변성 : 지금까지 r개 행을 출력
int r = 0;

// r을 0으로 설정하면 불변성은 참
while (r != rows)
{
    // 이 지점에서 불변성은 참
    // 하나의 행을 출력하면 불변성은 거짓
    std::cout << std::endl;

    // r을 증가시키면 불변성은 다시 참
    ++r;
}
// 따라서 이 지점에서 불변성은 참
```

## 행 출력하기
처음으로 살펴볼 것은 출력할 각 행이 모두 '같은 길이'라는 점입니다. 직사각형 모양의 배열로 생각한다면
**<u>각 행의 길이는 배열의 열 개수</u>**에 해당합니다. 해당 개수는 **<u>인사말의 길이</u>**에
**<u>두 번의 공백</u>**과 **<u>별표 2개</u>**를 더해서 계산할 수 있습니다.

```c++
const std::string::size_type cols = greeting.size() + pad * 2 + 2;
```

const로 정의된 cols이므로 상수라는 것을 간단하게 알 수 있지만 std::string::size_type처엄 익숙하지 않은 타입이 존재합니다.

- 첫 번째 `::`
  - 범위 연산자이며, std::string은 std라는 네임스페이스에 속한 string이라는 기능을 사용한다는 것을 의미
- 두 번째 `::`
  - string이라는 클래스에 속한 size_type이라는 기능을 사용한다는 것을 의미

네임스페이스나 블록과 마찬가지로 클래스는 자체적인 범위가 있습니다. std::string 타입은 size_type을
**<u>문자열의 문자 개수</u>**를 보유하는데 적한한 타입으로 정의합니다.

물론 cols의 타입을 int로 정의할 수 있습니다. 하지만 입력 값의 길이가 int의 범위를 넘을 수 있기 때문에
위처럼 정의하는 것이 좋습니다.
{: .notice--warning}

문자열의 길이는 음수가 될 수 없습니다. 따라서 std::string::size_type은 `부호 없는unsigned 타입`입니다.
부호 없는 타입의 객체는 음수값을 포함할 수 없습니다.

행 출력 역시 while문으로 출력할 수 있습니다.

```c++
std::string::size_type c = 0;

// 불변성 : 현재 행에서 c개 문자를 출력
while (c != cols)
{
    //하나 이상의 문자를 출력
    // 불변성을 참으로 유지하려고 c 값을 변경
}
```

### 테두리 문자 출력하기
우리가 출력할 것을 생각해보면...

- 첫 번째 행 또는 마지막 행
- 첫 번째 열 또는 마지막 열

테두리를 표현하기 위해 둘은 별표가 출력되어야 합니다. 루프 불변성을 사용해 별표의 출력 여부를 결정할 수 있습니다.

행에서의 예를 들면 r이 0일 땐 아직 출력된 행이 없어 첫 번째 행을 출력하는 중임을 의미합니다.
또한 r이 rows - 1일 땐 마지막 행을 출력 중임을 알 수 있습니다.

해당 개념을 사용해 코드를 작성해봅시다.

```c++
// 불변성 : 현재 행에서 c개 문자를 출력
while (c != cols)
{
    if (r == 0 || r == rows - 1 || c == 0 || c == cols - 1)
        std::cout << "*";
    else
    {
        // 하나 이상의 테두리 외 문자를 출력
        // 불변성을 참으로 유지하려고 c 값을 변경
    }
}
```

#### if문
while문의 본문은 if문을 포함하는 하나의 블록으로 구성되며 별표를 출력하지 결정하려고 if문을 사용합니다.

```c++
if (조건)
    실행문

if (조건)
    실행문 1
else
    실행문 2
```

while문과 마찬가지로 '조건'은 **<u>참 또는 거짓</u>**을 반환하는 표현식입니다. 조건이 참이면 프로그램은 if 이후의 실행문을 실행합니다.

#### 논리 연산자
```c++
r == 0 || r == rows - 1 || c == 0 || c == cols - 1
```

이 조건은 r이 0 또는 rows - 1이거나 c가 0또는 cols - 1이면 참입니다.

C++ 프로그램은 할당 연산자인 '='가 아닌 '=='기호를 사용해서 `항등equality` 여부를 판별합니다.
`논리합logical-or연산자`인 '||'는 피연산자 중 하나가 참이면 참을 반환합니다.

관계 연산자는 산술 연산자보다 `우선순위precedence`가 낮습니다. 예를 들어 r == rows - 1은
(r == rows) - 1이 아닌 `r == (rows - 1)`과 같습니다.

산술 연산자 '-'는 관계 연산자 '=='보다 우선순위가 높습니다.
{: .notice--warning}

논리합 연산자는 피연산자 중 하나가 참인지 판별합니다.

```c++
조건 1 || 조건 2
```

### 테두리 외 문자 출력하기
이제 테두리에 속하지 않는 문자를 처리해야 합니다. 이 문자는 인사말의 일부이거나 공백입니다.

인사말의 첫 번째 문자를 언제 출력할지 판별해야 합니다.

- 행
  - 별표만으로 이루어진 첫 번째 행의 다음 행부터 pad만큼의 행을 더함
- 열
  - 별표를 출력하는 첫 번째 열의 다음 열부터 pad만큼의 행을 더함

불변성을 적용하면 r이 pad + 1이고 c가 pad + 1인 위치가 인사말의 첫 번째 문자를 출력할 위치입니다.

```c++
if (r == pad + 1 && c == pad + 1)
{
    std::cout << greeting;
    c += greeting.size();
}
else
    std::cout << " ";
```

if문 조건에서는 `논리곱logical-and 연산자`를 사용합니다. || 연산자처엄 && 연산자는 두 조건을 판별하여 진릿값을 반환합니다.

|| 연산자와 달리 && 연산자는 두 조건이 모두 참일 때만 참을 반환합니다. 두 조건 중 하나라도 거짓이면 거짓입니다.
두 번째 조건은 첫 번째 조건이 참일 때만 판별합니다.

## 프로그램 완성하기
전체 프로그램을 살펴보면서 불필요한 코드를 정리합시다.

- 표준 라이브러리에서 가져온 모든 기능을 다루기
- while문 축약하기
- c 값을 한 군데에서 증가시키기

### std::의 반복 사용 줄이기
사실 지금까지 귀찮을 정도로 std::를 붙여썼습니다. 이는 표준 라이브러리에서 가져온 기능임을 나타냅니다.

```c++
using std::cout;
```

하지만 위 코드를 작성하면 cout라고만 작성해도 std::cout와 같은 의미로 사용하게 됩니다.

이러한 선언을 `using 선언using-declaration`이라고 합니다. using 선언한 이륾은 다른 이름과 비슷하게 동작합니다.

중괄호 안에서 using 선언으로 정의한 이름은 그 지점부터 중괄호가 끝날 때까지만 유효합니다.
{: .notice--warning}