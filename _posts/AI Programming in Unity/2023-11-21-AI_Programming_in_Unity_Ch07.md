---
title:  "[유니티 게임 AI 프로그래밍] 007. 퍼지 로직을 사용한 인공지능 개선"
excerpt: "퍼지 로직을 사용하는 방법에 대해 알아봅시다!"

author: gunnHB
categories: 
 - AI Programming
tags: 
 - [Github, Git, Unity, Programming, AI Programming, C#]

toc: true
toc_sticky: true
 
date: 2023-11-21
last_modified_at: 2023-11-21
---

🔔 유니티 게임 AI 프로그래밍 2/e 서적을 정리한 내용입니다. 🔔
{: .notice}

<div class="notice--info" markdown="1">
퍼지 로직을 활용하면 좀 더 섬세한 방식으로 게임의 규칙을 표현할 수 있습니다.
기본적으로 퍼지 로직은 수학과 매우 관련 있습니다. 물론 해당 포스트에서 다루는
내용은 한계가 있습니다. 이 글을 보고 계시는 분 중 수학에 관심과 조예가 깊은 
분이시라면 다양한 형태로의 응용을 찾아보시는 것을 추천드립니다.

- 퍼지 로직의 정의
- 퍼지 로직은 주로 어디에 사용하는가
- 퍼지 로직 컨트롤러 구현 방법
- 퍼지 로직 개념을 사용하는  다양한 형태
</div>

## 퍼지 로직 정의
`바이너리 로직`은 참 또는 거짓, 0 또는 1처럼 양자택일의 형태를 띄고 있다면
`퍼지 로직`은 0 과 1 사이의 부동소수 데이터를 이용하여 훨씬 다양한 가능성을 가집니다.

퍼지 로직은 특정하지 않은 데이터에 기반해 의사 경정을 내립니다. 온도를 예로 든다면,
맑은 여름날 캘리포니아는 구체적으로 온도르 재보지 않아도 따뜻하다는 사실을 알 수 있습니다.
반대로 겨울 알래스카 역시 온도를 재보지 않아도 춥다는 사실을 알 수 있습니다. 이와 같은
춥다, 시원하다, 덥다, 따뜻하다 같은 개념들이 퍼지에 해당합니다. 퍼지 로직을 사용하면
이런 개념을 모델링하고 일련의 규칙을 사용해 결과를 얻어낼 수 있습니다.

일반적으로 사람들이 의사결정을 내릴 때 애매한 영역이 존재합니다. 다시 말하면
항상 검정과 흰색이 아니라는 의미입니다. 식사를 한지 몇 시간이 지났고 슬슬 허기를
느끼기 시작한다고 해봅시다. 정확한 시간을 기준으로 배가 고프기 시작해서 언제 식사를
해야한다라고 정확히 나눌 수 없을 것입니다.

의사결정을 내릴 때는 다양한 요소가 관여하므로 이를 처리하는 퍼지 로직 컨트롤러가 필요하며
이는 가능한 많은 데이터를 참고해 결과를 도출합니다. 위에서 언급한 허기짐에 관련된 예시를
다시 보면 시간만을 고려했습니다만 실제 영향을 주는 요소는 다양합니다. 식사 후 얼마나
움직였는지 같은 사항을 고려할 수 있습니다.

퍼지 로직 시스템은 태생적으로 매우 유연합니다. 입력을 제공하면 퍼지 로직은 출력을 제공합니다.
하지만 항상 퍼지 로직이 출력의 형태만을 띄는 것은 아닙니다. 레이싱 게임을 예로 들면
부스트를 사용할 수 있는 차를 에이전트로 생각했을 때 부스트의 사용 시간 또는 사용 정도를
퍼지 로직으로 표현할 수 있습니다.

## 바이너리 시스템 대신 퍼지 시스템 얻기
당연히도 퍼지 로직을 사용하는 것은 `많은 비용`이 들어갑니다. 그렇기에 선별적인 사용이 필요합니다.
물론 복잡한 시스템이 항상 좋은 것은 아니기에 게임의 특성에 따라 바이너리 시스템이 더 유리할 수 있습니다.

"단순할수록 좋다. 하지만 너무 단순해서는 안된다." 라는 격언의 의미를 생각해보면 좋습니다.
게임의 인공지능을 구현할 때 필요한 목표를 충족시키는 선에서 단순해야 한다는 것입니다.

## 퍼지 로직 사용
퍼지 로직은 데이터 처리에 강점을 지닙니다. 인간이 사고하고 행동하는 양식을 데이터화해 처리한 후
다시 시스템에서 사용할 수 있는 정보로 변환하는 형태로 동작합니다.

퍼지 로직 컨트롤러는 다양한 실 세계 응용 사례를 가집니다.

- 냉난방 시스템
    - 퍼지 로직을 설명할 때 흔히 사용하는 온도 예시는 이론적인 것만은 아니며 실제로도 훌륭한 적용 사례입니다.
- 자동차
    - 신형 자동차는 매우 정교한 컴퓨터 시스템을 내장하고 있습니다. (냉난방, 연료 전달, 자동 브레이킹..)
      자동차에 컴퓨터를 탑재하기 시작하면서 기존에 사용하던 구식의 바이너리 시스템에 비해
      효율성이 크게 올랐습니다.
- 스마트폰
    - 조명에 따라 밝기 조절이 되는 시스템은 주위 조명뿐만 아니라 표현하는 컬러의 종류, 현재 배터리의 상태 등을
      종합적으로 고려합니다.
- 세탁기
    - 세탁물의 양이나 물의 탁한 정도, 온도와 다른 다양한 요소를 넣어서 매 세탁 과정에서 물의 사용량과
      에너지 소비량, 세탁 소요 시간 등을 최적화합니다.

주위를 둘려보면 다양한 곳에서 퍼지 로직이 사용되고 있음을 알 수 있습니다. 하지만 우리는
게임에서의 예시를 더 살펴보겠습니다.

### 간단한 퍼지 로직 시스템 구현
RPG 세상에 살고 있는 마법사 `밥Bob`이 있습니다. 밥은 매우 강력한 치유 마법을 가지고 있는데,
그는 남아있는 체력에 기반해 언제 마법을 사용할지 결정합니다.

```c#
if(healthPoints <= 50>)
{
    CastHealingSpell(me);
}
```

밥의 체력이 2가지 상태 중 하나를 가지는 것을 볼 수 있습니다. 물론 해당 스크립트는 아무 문제가 없습니다.
하지만 퍼지 로직을 사용했을 때 동일한 시나리오가 어떻게 바뀌는지 확인해보겠습니다. 일단 밥의 체력 상태부터 결정해봅시다.

![image](https://github.com/GunnHB/gunnHB.github.io/assets/117302300/7fe85b82-4af9-4f28-91ac-9d66e86c4ba2){: width="70%" height="70%"}

해당 차트가 어떻게 구성됐는지는 크게 신경쓸 필요는 없습니다. 보시다시피 간단한 선형 함수로
이루어져 있습니다. 사실 그다지 퍼지스럽지 않지만 바이너리 시스템보단 분명 발전된 형태입니다.

멤버십 함수라는 개념도 살펴봅시다. 이 개념은 우리 시스템의 핵심 중 하나로 진정한 상태 판정에 도움을 줍니다.
예를 들어 밥이 마법을 사용하지 판단할 때 단순한 하나의 값에 의존하는 것이 아니라 정보를 몇 개의 논리적 단위로
나눈 후 이 정보들을 조합해 상황을 판단하도록 합니다.

위 예제에서 3가지 상태를 비교하고 평가해 종합적인 결론을 도출할 수 있습니다.

- 밥이 위험한 상태에 놓여 있다.
- 밥이 다쳤다.
- 밥이 건강하다.

이를 전문용어로 설정해야 하는 멤버십의 수준이라고 부릅니다. 일단 이 정보를 알아내면 에이전트는 다음에
어떤 행동을 해야 할지 결정할 수 있게 됩니다.

그림을 보면 동시에 두 개의 상태가 참이 될 수 있음을 알 수 있습니다.

- 위기 상태이면서 다침
- 건강한 상태이면서 다침

수직 값은 참의 수준을 나타내며 0부터 1 사이의 부동소수 값을 가집니다.

- 체력이 0%면 위기 상태 평가 값은 1이다. 이는 밥의 체력이 완전히 소진된 상태를 의미한다.
- 체력이 40%면 밥이 완전히 다친 상태다.
- 체력이 100%면 밥이 완전히 건강한 상태다.

위와 같은 `정확한 참 상태가 아닌 상태`가 바로 퍼지 상태입니다. 예를 들어, 밥의 체력이
65% 남았다고 하면 다음과 같이 시각화할 수 있습니다.

![image](https://github.com/GunnHB/gunnHB.github.io/assets/117302300/92d75956-1e3f-472c-98e0-a838e2e815cf){: width="70%" height="70%"}

이를 살펴보면 밥은 약간 다친 동시에 약간 건강한 것을 알 수 있습니다. 더 정확하게 말하자면
밥은 37.5% 다쳤고 12.5% 건강하며 0%의 위기인 상태입니다. 이를 책에서 제공하는 씬에서
살펴보면 다음과 같습니다.

![image](https://github.com/GunnHB/gunnHB.github.io/assets/117302300/89dd6850-169f-4271-bb61-bd63671f4880){: width="70%" height="70%"}

지금은 이 데이터를 이용하여 아무런 일도 하지 않지만 앞으로는 이 데이터를 가지고 모든 것을
처리할 것입니다.

```c#
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class FuzzySample : MonoBehaviour
{
    private const string _labelText = "{0} true";

    public AnimationCurve _criticalCurve;
    public AnimationCurve _hurtCurve;
    public AnimationCurve _healthyCurve;

    public InputField _healthInput;

    public Text _healthyLabel;
    public Text _hurtLabel;
    public Text _criticalLabel;

    private float _criticalValue = 0f;
    private float _hurtValue = 0f;
    private float _healthyValue = 0f;

    private void Start()
    {
        SetLabel();
    }

    public void EvaluateStatements()
    {
        if(string.IsNullOrEmpty(_healthInput.text))
            return;

        float inputValue = float.Parse(_healthInput.text);

        _healthyValue = _healthyCurve.Evaluate(inputValue);
        _hurtValue = _hurtCurve.Evaluate(inputValue);
        _criticalValue = _criticalCurve.Evaluate(inputValue);

        SetLebel();
    }

    private void SetLabel()
    {
        _healthyLabel.text = string.Format(_labelText, _healthyValue);
        _hurtLabel.text = string.Format(_labelText, _hurtValue);
        _criticalLabel.Text = string.Format(_labelText, _criticalValue);
    }
}
```

### 세트 확장
