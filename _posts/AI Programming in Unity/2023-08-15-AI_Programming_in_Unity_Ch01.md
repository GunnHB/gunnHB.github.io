---
title:  "[유니티 게임 AI 프로그래밍] 001. 게임에서의 인공지능 기초"
excerpt: "게임에서 사용되는 인공지능을 가볍게 알아봅시다!"

author: gunnHB
categories: 
 - AI Programming
tags: 
 - [Github, Git, Unity, Programming, AI Programming, C#]

toc: true
toc_sticky: true
 
date: 2023-08-15
last_modified_at: 2023-08-16
---

🔔 유니티 게임 AI 프로그래밍 2/e 서적을 정리한 내용입니다. 🔔
{: .notice--primary}

<div class="notice--info" markdown="1">
일반적으로 `인공지능`은 복잡하고 어려운 주제라고 생각하기 쉽습니다.

1장에서는 인공지능 배경 지식을 살펴보고 이를 게임에 적용하는 방법에 대해
가볍게 다룰 예정입니다.

- 게임에서의 인공지능 적용과 구현이 다른 분야와 다른 점
- 게임에서의 인공지능을 적용할 때 필요한 요구사항
- 게임에서 사용하는 기초적인 인공지능 패턴

1장의 내용은 유니티에서의 인공지능 패턴을 구현함에 있어 필요한 참고 자료를 제공하는 역할입니다.
</div>

## 가상의 삶 구현

동물이나 사람처럼 생명체는 매 순간 행동을 결정하는 데 필요한 지적 능력을 갖추고 있습니다.
우리의 뇌는 여러 감각 기관을 통해 들어온 자극을 처리 가능한 형태의 `정보`로 변환할 수 있지만
컴퓨터는 논리적이고 수리적인 `연산`만이 가능합니다.

인공지능이란 이런 컴퓨터가 마치 '사람'처럼 생각하고 `의사결정`을 내리는 것처럼 보이게 하는 기술입니다.

인공지능 관련 연구 분야는 어렵고 방대하지만, 우선 각 분야에서 사용 중인 인공지능의 기본적인 내용을
살펴보면 다음과 같습니다.

- 컴퓨터 비전
    - 비디오나 카메라 등으로부터 시각적인 입력을 받아 이를 분석해
      얼굴 인식이나 사물 인식, 광학 문자 판독 등의 처리를 수행하는 능력
- 자연어 처리
    - 기계가 마치 사람처럼 언어를 읽고 이해하는 능력
- 상식 추론
    - 우리의 뇌가 온전히 알지 못하는 분야에 대해 어떤 답을 꺼낼 때 사용되는 기술
- 머신 러닝
    - 컴퓨터 프로그램을 일반적으로 명령어의 정적 집합으로 구성되는데,
      이는 입력을 받아 출력을 전달하는 형태

## 인공지능을 사용한 게임성 강화

게임에 인공지능이 적용된 역사를 거슬러 올라가다 보면 `팩맨Pack-Man`을 만날 수 있습니다.
`블링키`, `핑키`, `잉키`, `클라이드`로 구성된 적 캐릭터들은 각기 고유한 행동으로 플레이어를 위협했고,
이는 30년도 더 지난 현재까지도 이 게임을 그리워하게 만들기엔 충분했습니다.

게임 기획자는 플레이어게 적절한 도전 욕구를 자극하도록 게임을 설계해야 하는데,
인공지능을 사용하면 게임 내의 적을 마치 살아있는 생명체처럼 움직이도록 할 수 있어 큰 도움이 됩니다.

게임에서의 인공지능의 역할은 함께 경쟁할 수 있는 개체인 `NPC`를 제공해 게임 월드에 현실감을 불어넣는데 있습니다.
다만 현실 세계를 그대로 모방하기보다는 마치 NPC 가 지능을 갖추고 살아있는 듯한 '느낌'을 주는 수준이면 충분합니다.

## 에이전트 정의

인공지능에서 말하는 에이전트는 인공지능을 지닌 `개체`를 말합니다.
다시 말하자면 복잡한 행동 패턴을 가지고 지능이 있는 것처럼 행동하는 모든 개체가 `에이전트`입니다.

여기서 게임 개체는 캐릭터일 수도 있고 생명체나 이동 수단 등 뭐든 가능합니다.

## 유한 상태 기계

`유한 상태 기계`는 가장 단순한 형태의 인공지능 모델로 널리 사용합니다.
상태 기계는 기본적으로 다양한 상태를 가지며 이 상태 간에 전이가 가능한 모델을 말합니다.
게임 개체는 초기 상태에서 출발해 특정 이벤트와 규치에 따라 다른 상태로 변화합니다.
게임 개체는 동시에 하나의 상태만 가질 수 있다는 점이 중요합니다.

간단한 FSM 은 기본적으로 4가지 컴포넌트로 구성됩니다.

- 스테이트
    - 게임 개체나 NPC 가 선택할 수 있는 상태의 세트를 정의합니다.
- 트랜지션
    - 서로 다른 상태 산의 관계를 정의합니다.
- 룰
    - 상태를 전이하는 데 사용합니다.
- 이벤트
    - 룰 검사를 시작하도록 하도록 합니다.

유한 상태 기계는 상대적으로 구현이 간단하고 시각적이며 이해하기 쉬워서 널리 사용되는 인공지능 기술입니다.
간단히 `if`/`else` 구문이나 `switch` 구문을 사용해 구현할 수 있지만 처리해야 하는 상태와 전이가 많아지면
간단한 조건문으로 처리하기에 한계가 있습니다.

## 에이전트의 눈으로 월드 바라보기

에이전트가 이벤트에 제대로 반응하려면 주변의 환경이나 플레이어,
다른 에이전트 등에 대한 정보를 가지고 있어야 합니다.

실제 생명체와 같이 우리의 에이전트도 여러 자극 등에 의존하여 정보를 얻어야 하지만
실제 게임 내에서 우리는 플레이어의 위치, 이벤토리 정보 등 원하는 정보에 접근이 가능하므로
이 중 일부만 적절하게 에이전트에게 제공하면 됩니다.

## 길 찾기와 조향

우리는 인공지능 캐릭터가 게임 월드에서 정교한 지형을 따라 스스로 이동하길 바랄 떄가 있습니다.
예를 들어 레이싱 게임에서는 트랙을 따라 주행해야 하며, RTS 게임에서의 유닛들은 이동 가능한 지형이면
지형을 헤치고 어디든 이동할 수 있어야 합니다.

인공지능을 갖춘 에이전트라면 목적지로 이동할 수 있는지 판단 가능해야 하며, 가장 효율적인 경로로
이동할 수 있어야 하고 중간에 장애물이 나타나면 경로를 수정할 수 있어야 합니다.

## A* 길찾기

많은 게임에서 몬스터나 적들이 플레이어를 따라다니거나 장애물을 피해가며 특정 지점으로 이동합니다.
예를 들어 RTS 게임에서 선택한 그룹의 유닛들은 장애물과 충돌하지 않고 목적지에 도달하는 경로를 탐색해야 합니다.
여기서 장애물을 피하는 방법은 유닛에 따라 다를 수 있는데, 공중 유닛의 경우 산을 넘어갈 수 있지만
지상 유닛은 산을 둘러 가야 합니다.

`A*` 는 성능이 좋고 정확도가 높아 게임에서 널리 사용하는 `경로 탐색 알고리즘`입니다.
이는 맵을 타일 형태로 구성하여 시작점부터 장애물이 아닌 타일로 이동해가면서 점수화하고 이 점수를 통해
`최단 경로`를 찾아낼 수 있습니다.

## 내비게이션 매시

A* 길 찾기를 사용해 장애물을 피해가는 최단 경로를 계산하는 데는 생각보다 많은 연산이 필요합니다.
이를 간단히 하고 쉽게 인공지능 캐릭터가 경로를 찾도록 하기 위해 `웨이포인트`를 사용하는 방식을 사용하게 됩니다.

이를 이용하면 간단히 가장 가까운 웨이포인트만 찾아서 목적지를 향해 이동하면 됩니다.
하지만 이 방식은 맵에 장애물이 추가될 때마다 웨이포인트도 갱신해야 하는 불편함이 존재합니다.

인공지능 캐릭터는 각 노드를 직선으로 연결하는 경로를 따라 차례로 이동하며 목적지에 도달합니다.
하지만 경로가 벽과 너무 가까이 닿아 있으면 캐릭터가 벽에 걸려 오도 가도 못하는 상황에 빠질 수 있습니다.

이럴 때 가장 유용하게 사용할 수 있는 기능이 `NevMesh` 입니다. NevMesh 는 일종의 그래프 구조로 격자 타일 기반의 구조 또는
웨이포인트 그래프와 유사한 방식으로 월드를 표현하는 방법입니다.

## 군집 처리

많으 종류의 새나 물고기, 곤충, 육상 동물 같은 생명체는 이동이나 사냥, 수렵 등을 할 때 무리를 지어 행동합니다.
새의 무리가 하늘에서 떼 지어 이동하는 상황에서 만일 모든 새에 대해 개별적으로 이동과 애니메이션 처리를 한다면
노력과 시간이 많이 듭니다. 하지만 각 새가 따라야 하는 간단한 `규칙`을 정해둔다면 복잡하고 집단적인 행동을 하는
그룹의 행동을 구현할 수 있습니다.

유사하게 걸어 다니거나 탈것을 사용하는 사람의 무리도 개별 개체를 일일이 모델링하지 않고 집단 형태로 모델링할 수 있습니다.
집단에 속한 개별 개체는 단지 자신이 속한 집단이 어디로 이동하고 있는지 그리고 무리 내에서 가장 `가까운 이웃` 개체가
누구인지 정도만 알고 있으면 충분합니다.

## 행동 트리

`행동 트리`는 인공지능 캐릭터를 실제로 표현하고 제어하는 또 다른 패턴입니다.
위에서 언급한 `FSM` 은 각 상태를 정의하고 상태 간의 전이를 통해 인공지능 캐릭터를 제어하는 아주 간단하고 쉬운 기술입니다.
하지만 FSM 은 규모 확장에 불리하고 기존 로직을 재활용하기에 불리합니다. FSM 을 사용해서 규모를 확장하려면
필요한 수만큼의 상태를 추가하고, 각 상태를 모두 직접 연결해 상태 간의 트랜지션을 직접 처리해야 합니다.

행동 트리는 `노드의 집합`으로 계층 구조의 형태로 구성되며 노드는 부모에 연결되는 형태입니다.
구성된 형태가 나무의 가지를 닮았기 때문에 행동 트리라고 불립니다.

FSM 에서 주요 요소가 `스테이트`였다면, 행동 트리의 기본 구성요소는 `태스크 노드`입니다.
태스크에는 `시퀀스`, `셀렉터`, `패래럴`, `데코레이터` 등이 있습니다.

`셀렉터 태스크`는 물음표를 안에 표시한 원으로 표현합니다. 일단 행동 트리는 플레이어 공격을 선택합니다.
만일 공격 테스크가 성공을 반환하면 셀렉터 태스크는 완료되며 부모 노드가 있다면 부모 노드로 돌아갑니다.
그렇지 않고 공격 태스크가 실패하면 추격 태스크를 시도합니다. 만일 추격 태스크도 실패하면 정찰 태스크를 시도합니다.

다음으로 화살표가 그려진 직사각형은 `시퀀스 태스크`를 의미합니다. 최상위 셀렉터는 첫 번째 `시퀀스 액션`을 선택합니다.
이 시퀀스 액션의 첫 번째 태스크는 플레이어 캐릭터가 충분히 공격할만한 거리에 있는가를 검사합니다. 만일 태스크가 성공하면
다음 태스크르 진행합니다. 여기에서 다음 태스크는 플레이어를 공격하는 행동입니다. 만일 공격도 성공하면 전체 시퀀스는
성공을 반환하며 이 행동에 대한 셀렉터는 종료되고 다른 시퀀스 태스크로 이어지지 않습니다. 또한 충분히 공격할 만한 거리에
있는가를 검사하는 태스크가 실패하면, 다시 말해 플레이어가 공격 가능 범위에 있지 않다면 공격 태스크를 진행하지 않고
부모 셑렉터 태스크에 실패를 반환합니다. 그러면 셀렉터는 시퀀스 내의 다음 태스크를 선택합니다.

`패래럴` 태스크는 모든 자식 태스크를 동시에 실행합니다. 참고로 시퀀스와 셀렉터 태스크는 자식 태스크를 하나씩 실행합니다.
`데코레이터` 태스크는 단 하나의 자식만 가질 수 있는 형태의 태스크로 자식 태스크의 실행 여부나 실행 횟수 등을 변경할 수 있습니다.

## 퍼지 로직

`퍼지 로직`은 정확한 결과보다는 근사치의 결과를 내는 로직을 의미힙니다. 퍼지 로직과 추론 등의 기봅은 좀 더 나은 인공지능을
구현하고자 할 때 주로 사용합니다.

1인칭 슈팅 게임에서 한 군인이 유한 상태 기계나 행동 트리를 통해 의사 결정이 내려진다면 단순 조건에 예외 없이 동작하는
`매우 단조로운 형태`를 가지게 됩니다. 하지만 퍼지 로직을 적용하면 이 군인이 플레이어를 발견하더라도 자신의 무기 상태와
체력 정보, 주위의 동료 정보 등을 모두 종합해 실제 공격 여부를 판단하도록 하여 훨씬 `자연스러운 인공지능 군인`을 구현할 수 있습니다.

## 요약

학문적인 인공지능이 자원의 제약을 고려하지 않은 상태에서 실세계의 문제를 해결하고 이론을 증명하는 데 주력한다면,
게임 인공지능은 제약된 자원을 고려한 상태에서 플레이어와 교감할 수 있는 `NPC`를 만드는 데 주력합니다.

1장에서는 실제 게임을 만들 때 주로 사용되는 개념들을 간략히 살펴보았고, 2장부터는 이런 개념들을 실제 게임에 적용하는 방법을
좀 더 구체적으로 살펴보겠습니다.