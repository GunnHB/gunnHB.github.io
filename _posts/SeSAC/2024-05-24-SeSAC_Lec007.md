---
title:  "[SeSAC] 006. 클래스"
excerpt: "객체지향 프로그래밍에 대한 정의와 클래스에 대한 내용입니다!"

author: gunnHB
categories: 
 - SeSAC
tags: 
 - [Github, Git, Unreal, Programming, C++]

toc: true
toc_sticky: true
 
date: 2024-05-24
last_modified_at: 2024-05-27
---

## 객체지향 프로그래밍
C++는 C언어에 기능이 더 추가된 언어입니다. 기본적으로 C는 `절차지향 프로그래밍`입니다. 절차지향 프로그래밍은 <u>순서에 의존적인 프로그램</u>으로
컴퓨터의 처리구조와 유사하여 속도가 빠르다는 장점이 있습니다. 하지만 유지보수의 어려움이 있고 엄격한 실행 순서로 인해 비효율적입니다.

이에 반해 C++는 `객체지향 프로그래밍`입니다. 먼저 `객체`란 <u>세상의 모든 사물</u>을 의미합니다. 객체는 `데이터`와 `기능`을 가지고 있고 
이러한 <u>객체들이 유기적인 상호작용을 하도록 구성하는 것</u>이 객체지향 프로그래밍입니다.

### 객체지향 프로그래밍의 특징
캡슐화, 다형성, ...

## 클래스
`클래스`는 <u>객체를 생성하기 위해 C++에서 지원하는 문법</u> 중 하나입니다. 여러 멤버 변수와 함수를 가질 수 있습니다.

클래스와 구조체는 약간의 차이만 있지 거의 동일합니다.
{: .notice--info}

하나 주의해야 할 것은 <u>'클래스는 객체가 아니다.'</u>입니다. 객체는 선언된 변수 즉, `인스턴스`를 의미합니다. 클래스는 <u>객체를 만들기 위한 수단</u>으로 이해해야 합니다.

동적할당 역시 객체입니다.
{: .notice--info}

```c++
// 클래스 기본 구조
// class 클래스 이름
// {
//     멤버 변수 및 멤버 함수
// };

// 언리얼에서는 일반적으로 클래스명 앞에 A나 U를 붙이지만
// 해당 예시에서는 클래스의 C를 붙였다.
class CPlayer
{
    char mName[32];
    int mAttack;
};

int main()
{
    CPlayer _player;

    // _player.mAttack = 100;  // 에러!
    return 0;
}
```

클래스를 선언하고 멤버 변수에 값을 할당하려고 했지만 어째서인지 변수를 사용할 수 없습니다. 여기서 <u>구조체와 클래스의 차이</u>가 나타나게 됩니다.

### 접근 지정자
`접근 지정자`는 <u>멤버 접근을 지정해주는 키워드</u>입니다.

|키워드|내용|
|---|---|
|public|클래스 내부와 외부에서 모두 접근이 가능|
|private|클래스 내부에서만 접근이 가능|
|protected|본 클래스와 상속받은 클래스 내부에서만 접근이 가능|

- 내부
    - 클래스의 멤버 함수 안을 의미
- 외부
    - 클래스의 멤버 함수를 제외한 다른 곳을 의미

구조체는 접근 지정이 없을 경우 기본적으로 `public`으로 설정되지만 클래스는 기본적으로 `private`입니다.
그렇기 때문에 위 예시에서 접근할 수 없어 에러가 발생한 것입니다.

```c++
#include <iostream>;

class CPlayer
{
public:
    char mName[32];
    int mAttack;
private:
    void Test()
    {
        std::cout << "TEST" << std::endl;
    }
};

int main()
{
    CPlayer _player;

    _player.mAttack = 100;  // 할당 가능
    // _player.Test();      // 접근 지정자로 인해 호출 불가능

    return 0;
}
```

클래스의 멤버 변수는 private으로 선언하는 것이 좋습니다. 만약 중요한 데이터를 여러 군데에서 사용하다가 버그가 발생할 경우 어느 곳에서 값이 잘못 들어간 것인지
확인하기 까다롭기 때문입니다. 그렇기 때문에 함수를 이용해 사용처를 분명하게 하는 것이 좋습니다.

```c++
class CPlayer
{
private:
    char mName[32];
    int mAttack;

public:
    void SetAttack(int attack)
    {
        mAttack = attack;
    }
    int GetAttack()
    {
        return mAttack;
    }
}

int main()
{
    CPlayer _player;

    _player.SetAttack(100);
    _player.GetAttack();

    return 0;
}
```

이와 같은 함수를 `getter`, `setter` 함수라고 합니다.
{: .notice--info}