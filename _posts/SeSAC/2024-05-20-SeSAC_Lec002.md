---
title:  "[SeSAC] 002. C++의 조건문과 반복문"
excerpt: "C++에서의 조건문과 반복문에 대해 알아봅시다!"

author: gunnHB
categories: 
 - SeSAC
tags: 
 - [Github, Git, Unreal, Programming, C++]

toc: true
toc_sticky: true
 
date: 2024-05-20
last_modified_at: 2024-05-21
---

🔔 새싹 언리얼엔진을 활용한 게임프로그래머 양성과정 강의를 듣고 정리한 내용입니다. 🔔
{: .notice}

## 조건문
### if
`if`문은 <u>특정 조건을 지정하고 조건이 `true`인 경우 동작</u>되는 문법입니다. 이는 코드를
원하는 상황에서만 동작할 수 있도록 합니다.

```c++
// 조건식의 기본 형태
if (조건식)
{
    실행문
}
```

만약 실행문이 한 줄이라면 중괄호는 생략 가능합니다.
{: .notice--info}

조건문은 굉장히 많은 상황에서 사용됩니다. 게임에서 예를 들면 스킬을 사용할 때 쿨타임 동안에는 사용할 수 없게 하거나,
보스 몬스터의 체력이 50% 이하일 때 다음 페이즈로 넘어가는 등의 시스템을 만들 수 있습니다.

만약 if문의 조건식과 다른 조건을 추가하고 싶다면 `else if`를 추가할 수 있습니다. 만약 조건에 만족하지 못했을 때는
`else`를 사용하여 예외처리를 추가할 수 있습니다.

```c++
if (조건문 1)
{
    실행문 1
}
else if (조건문 2)
{
    실행문 2
}
else
{
    실행문 3
}
```

if문은 독립적으로 사용할 수 있지만 else if와 else문은 반드시 if문 다음에 작성되어야 합니다.
{: .notice--info}

### 삼항연산자
`삼항연산자`는 <u>if ~ else 문을 한 줄로 늘여 쓴 것</u>과 같습니다. 이는 조건을 체크하여 true일 경우와
false인 경우 할당할 값을 지정할 수 있습니다.

```c++
// 조건식 ? true인 경우 값 : false인 경우 값
int number = 3 < 10 ? 3 : 10;

// 위 코드를 if문으로 바꾼다면...
int number2 = 0;

if(3 < 10)
    number = 3;
else
    number = 10;
```

삼항연산자에 경우 가독성이 좋지만 개개인 마다의 호불호가 있습니다. 유의하여 사용합시다.
{: .notice--info}

### switch
`switch`문은 <u>변수를 상황 별로 조건을 나눠 동작</u>시키는 문법입니다.

```c++
// 기본 형태
// switch(변수)
// {
//     case 상수 1:
//         break;
//     case 상수 2:
//         break;
//     case 상수 3:
//         break;
//     default:
//         break;
// }

int number = 2;

switch(number)
{
    case 1:
        //실행문
        break;
    case 2:
        //실행문
        break;
    case 3:
        //실행문
        break;
    default:
        //실행문
        break;
}
```

switch문에서의 `break`는 해당 switch문을 빠져나오는 역할을 합니다. 만약 break를 작성하지 않는다면 해당하는 case문부터 
하위 case문의 실행문을 모두 실행합니다.(switch문이 종료되거나 break문을 만날 때까지)

case문에서는 변수를 선언할 수 없습니다. 만약 선언이 필요하다면 코드 블럭으로 묶어 진행하면 됩니다.
{: .notice--info}

#### 열거형
위의 switch문의 case에서 `상수`로 적은 것은 사실 바람직하지 않습니다. 예를 들어

```c++
/*
    직업
    1. Knight
    2. Archer
    3. Magician
    4. Assassin
*/

int job = 0;

switch(job)
{
    case 1:
        std::cout << "Knight"
    case 2:
        std::cout << "Archer"
    case 3:
        std::cout << "Magician"
    case 4:
        std::cout << "Assassin"
}
```

이렇게 상수만으로 코드를 작성하게 되면 작성한 본인만 이해할 수 있어 꽤나 하드 코딩이 됩니다. 이를 위해 `열거형enum`을 사용합니다.

열거형은 <u>상수에 이름을 부여해주는 기능</u>을 합니다.

```c++
// 기본 형태
// enum 열거형 이름
// {
//      요소 1,
//      요소 2,
//      요소 3,
// }
```

열거형의 요소들은 0부터 시작해 값이 1씩 증가합니다. 하지만 만약

```c++
// 기본 형태
// enum 열거형 이름
// {
//      요소 1,         // 0
//      요소 2 = 100,   // 100
//      요소 3,         // 101
// }
```

위와 같이 작성하게 되면 할당한 값부터 1씩 증가하는 형태가 됩니다.

열거형은 cpp가 제공해주는 타입이 아닌 프로그래머가 새롭게 추가하는, 일종의 사용자 정의 타입입니다. 열거형의 이름은 변수의 타입이 되고,
요소는 상수입니다.

열거형의 기본 크기는 4byte입니다.
{: .notice--info}

열거형은 충돌방지를 위해 namespace를 지정할 수 있습니다. 또한 열거형 이름 뒤에 원하는 타입을 작성하면 타입의 크기만큼 열거형의 크기가 결정됩니다.

```c++
namespace EJob
{
    enum Type : char    // char 크기(1byte)의 enum이 된다.
    {
        None = -1,  //-1
        Knight,     // 0
        Archer,     // 1
        Magician,   // 2
        Assassin,   // 3
    };
}

EJob job = EJob::Knight;

switch (job)
{
    case EJob1::None:
        break;
    case EJob1::Knight:
        break;
    case EJob1::Archer:
        break;
    case EJob1::Assassin:
        break;
    default:
        break;
}
```
## 반복문
`반복문`이란 <u>같은 코드를 여러 번 반복해서 동작</u>시켜주는 기능을 합니다. 종류에는 `for`, `while` `do while`이 있습니다.
### 난수
`난수`란 랜덤한 수를 의미합니다. cpp에서 난수를 생성하기 위해서는

```c++
rand();
```

위와 같은 코드를 사용해 나타낼 수 있습니다. 확인을 위해 rand();를 5개 정도 작성하여 출력해보면

![image](https://github.com/GunnHB/gunnHB.github.io/assets/117302300/8b8c3c40-992d-4c2a-895b-f62fd28b10ac){: width="70%" height="70%"}{: .align-center}
이러한 난수가 출력되는 것을 볼 수 있습니다. 하지만 콘솔창을 종료하고 다시 실행시켜도 결과는 같습니다. rand() 함수는 프로그램이 생성될 때 값이 정해지기 때문입니다.

이를 해결하기 위해 `srand`함수를 이용해야 합니다. 이 함수는 <u>인자 값(seed)을 받아 rand에 사용되는 수를 초기화하는 역할</u>을 합니다. rand 함수는 호출 시 srand의 seed 값을
기반으로 난수를 생성하는 것입니다.

그렇기 때문에 srand 함수의 seed 값은 가변적이어야 합니다. 프로그램에서의 가장 가변적인 수는 <u>시간</u>이기 때문에 현재 시간을 나타내는 함수인 `time(0)` 함수를 사용하면 됩니다.

time(0) 함수는 1970년 1월 1일부터 현재 시간까지를 `초sec`로 나타냅니다.
{: .notice--info}

```c++
#include <iostream>;
#include <time.h>;

int main()
{
    srand(time(0));
    rand();

    return 0;
}
```

추가적으로 첫 rand 함수는 특정 값(시간)에 1이 증가한 값만을 반환합니다. 그렇기 때문에 rand 함수를 한번 호출한 뒤부터 원하는 난수를 얻을 수 있습니다.

얻은 난수를 그대로 사용할 수 있지만 굉장히 큰 숫자이므로 가공할 필요가 있습니다. 예를 들어 주사위 시스템을 만든다고 해봅시다.우리는 1부터 6까지의 숫자만을 얻어야 합니다.
이를 위해서는 간단한 연산이 필요합니다.

```c++
...
16921 % 6 == 1
16922 % 6 == 2
16923 % 6 == 3
16924 % 6 == 4
16925 % 6 == 5
16926 % 6 == 0
16927 % 6 == 1
16928 % 6 == 2
16929 % 6 == 3
16920 % 6 == 0
...
```

위와 같이 특정 값을 주사위의 최대 값인 6으로 나눈 나머지는 0부터 5까지의 범위로 구성됩니다. 그렇기 때문에 1부터 6까지를 구하기 위해서는
계산된 값에 1을 더해주면 됩니다. 결과적으로 코드는

```c++
#include <iostream>;
#include <time.h>;

int main()
{
    srand(time(0));
    rand();

    std::cout << ((rand() % 6) + 1);    // 1부터 6까지의 숫자 중 하나의 수를 출력

    return 0;
}
```

위와 같이 작성할 수 있습니다.
### for
`for`문은 가장 일반적인 반복문입니다.

```c++
// for문의 기본 형태
for (초기값; 조건식; 증감값)
{
    실행문
}

// 초기값 : for문이 실행될 때 한번만 동작
// 조건식 : for문이 동작되는 동안 계속 동작
// 증감식 : for문이 동작되는 동안 계속 동작
```

증감식의 경우 `전위연산`이나 `후위연산`을 주로 사용하지만 때에 따라 `+=`나 `-=` 등의 연산자를 사용하기도 합니다.
{: .notice--info}

for문의 기본 동작은

1. 초기값 할당
2. 조건식 확인
3. 실행문
4. 증감값
5. 2 ~ 4반복

순서 입니다. 2번의 조건식 확인에서 결과가 `true`인 경우 실행문을 실행하고 값을 증감시킨 뒤 다시 조건식을 확인합니다. 
만약 해당 결과가 `false`인 경우 for문을 빠져나옵니다.

#### 중첩 for문
for문을 반드시 하나만 사용해야 하는 것은 아닙니다. for문 안에 for문을 작성하는 것을 <u>중첩 for문</u>이라고 합니다.

```c++
for (int index1 = 0; index1 < 10; index1++)
{
    for (int index2 = 0; index2 < 10; index2++)
    {
        std::cout << "index1 :" << index1 << ", index2 :" << index2 << std::endl;
    }
}
```

위와 같이 작성하면 for문은 100번의 반복을 실행할 것입니다. 이처럼 중첩 for문의 반복 횟수는 <u>각 for문 반복 횟수의 곱</u>이 됩니다. 
여담으로 위 반복문을 시간복잡도로 나타내면 <u>Ο(N * M)</u> 혹은 <u>Ο(N<sup>2</sup>)</u>이 됩니다.

for문을 여러 번 사용하는 경우는 빈번합니다. 하지만 삼중 이상으로 사용할 경우 속도가 크게 느려지기 때문에 사용을 지양합시다.
{: .notice--info}

### while
`while`문 역시 많이 사용하는 반복문입니다. 주로 `무한 루프`를 위해 사용됩니다.

```c++
// 기본 형태
while (조건식)
{
    실행문
}
```
while문은 <u>조건을 만족하면 무한히 반복</u>한다는 특징이 있습니다. 그렇기 때문에 while문의 코드 블럭에서도 조건을 걸어 반복문을 빠져나올 수 있는데,
그때 사용하는 것이 `break`문 입니다. 반복을 진행하다가 break를 만나게 되면 즉시 반복을 중단합니다. break문은 <u>모든 반복문에서 사용이 가능</u>합니다.

반대로 코드 블럭의 가장 상단으로 이동시키는 문법이 있는데, 이는 `continue`입니다. 반복을 진행하다가 continue를 만나게 되면 즉시 코드 블럭의 최상단으로 이동합니다.
이 역시 모든 반복문에서 사용이 가능합니다.
### do while
```c++
do
{
    실행문
}
while (조건식);
```

`do while`문의 특징은 실행문을 먼저 동작시킨 후 조건식을 확인하여 실행문을 반복한다는 것입니다. 이는 다시 말해
<u>처음 한번은 무조건 실행문이 동작</u>한다는 것입니다.