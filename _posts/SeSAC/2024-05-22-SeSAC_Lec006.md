---
title:  "[SeSAC] 006. define과 파일 입출력"
excerpt: "C++의 define과 파일 입출력에 대한 설명입니다!"

author: gunnHB
categories: 
 - SeSAC
tags: 
 - [Github, Git, Unreal, Programming, C++]

toc: true
toc_sticky: true
 
date: 2024-05-22
last_modified_at: 2024-05-22
---

## define
전처리기 중 하나인 `define`은 <u>정의된 내용을 사용한 공간에 코드로 복사</u>해주는 역할을 합니다.

```c++
#include <iostream>;

// define의 내용은 기본적으로 한 줄로 작성해야 한다.
#define TEST 10
#define OUPUTTEST std::cout << "Output test" << std::endl;
#define MacroNumber(num) std::cout << num << std::endl;

int main()
{
    std::cout << TEST << std::endl;     // 10 출력
    // ;는 define의 내용에 포함되기 때문에 작성하지 않아도 된다.
    OUTPUTTEST                          // Output test 출력

    // define의 인자는 타입의 제한이 없다.
    // 모든 타입이 다 들어올 수 있다.
    // 해당 define에 함수를 넣으면 함수의 주소를 출력한다.
    MacroNumber(10);
    MacroNumber(3.14f);
    MacroNnumber("나는 매크로");

    return 0;
}
```

또한 define을 이용해 간단한 조건식을 적용시킬 수 있습니다.

```c++
#include <iostream>;

// 만약 null로 할당된 포인터를 delete하게 되면 크래시가 발생한다.
// 그러니 조건을 걸어 삭제하는 것이 좋다.
#define SAFE_DELETE(p) if(p != nullptr) {delete p; p = nullptr;}

int main()
{
    // 동적 할당
    int* _pointer = new int;

    // 동적 할당된 데이터를 삭제
    SAFE_DELETE(_pointer);
    
    return 0;
}
```

이렇게 보면 define은 굉장히 편한 기능같지만 굉장히 치명적인 단점이 있는데, `디버깅`이 <u>불가능하다</u>는 것입니다.
그러므로 이 기능 역시 적당하게만 사용하는 것이 좋습니다.

### 댕글링 포인터
```c++
int* pointer = new int;
delete pointer;

*pointer = 100; // 에러!
```

`댕글링 포인터Dangling Pointer`는 <u>이미 할당 해제된 주소를 가리키는 포인터</u>입니다. 이미 해제된 영역을 참조하는 것이기 때문에 에러를 발생시킵니다.
상황에 따라 오류 없이 동작할 수도 있지만 이는 정상적인 동작이 아니기 때문에 버그의 원인이 됩니다.

이를 방지하기 위해서는 delete 처리된 포인터 변수를 `null`로 초기화시켜야 합니다.

```c++
int* pointer = new int;
delete pointer;

pointer = nullptr;  // null로 초기화

*pointer = 100; // 에러!
```

하지만 null로 초기화한 후 값을 할당하는 것 역시 에러를 발생시킵니다. 이는 코드 자체의 오류이기 때문에 이전 상황과 달리 쉽게 발견하고 수정할 수 있습니다.

## 파일 입출력
가끔 게임을 하다가 예기치 않게 종료될 때가 있습니다. 이미 배포된 게임에서 이런 상황이 발생하면 어디에서 오류를 발생시켰는지 찾아보기 힘듭니다.
이런 상황을 위해 개발자들은 게임의 <u>로그 파일을 만들어</u> 어느 지점에서 어떤 에러가 발생한 것인지 확인합니다. `파일 입출력`을 통해 파일을 쓰거나 읽습니다.

## C언어의 파일 입출력
C언어에서의 파일 입출력은 `fopen_s`함수를 사용합니다.

```c++
// FILE은 c언어에서 제공하는 filestream
FILE* _pFile = nullptr;

fopen_s(&_pFile, "test.txt", "wt");
```

fopen_s 함수의 인자를 확인해보면 첫 번째 인자로 <u>이중 포인터 변수</u>를 받습니다. 이유를 알아보자면

```c++
void TEST1(FILE* file)
{
    file = new FILE;
}

void TEST2(FILE** file)
{
    *file = new FILE;
}
```

먼저 TEST1 함수의 경우 포인터 변수를 받아 포인터 변수에 동적할당을 진행합니다. 여기서 사용되는 포인터 변수는 <u>지역변수</u>이기 때문에 함수를 빠져나가면 메모리에서 삭제됩니다.
그 말은 <u>동적할당한 주소가 사라진다는 것</u>이기 때문에 문제가 발생합니다.

반면 TEST2 함수의 경우 이중 포인터 변수를 통해 해당하는 <u>주소를 받아 그 주소에 동적할당을 진행</u>합니다. 이렇게 되면 <u>인자로 받은 포인터에 동적할당을 하는 것</u>이므로
동적할당된 주소는 삭제되지 않고 남아있는 것입니다. (포인터 인자 값이 곧 동적할당의 주소)

동적할당은 힙 영역에 공간을 만들어 주소를 반환합니다.
{: .notice--info}

fopen_s의 다음 인자는 `파일의 경로`가 들어갑니다. 파일의 경로는 `상대 경로`와 `절대 경로`로 나뉩니다.

1. 상대 경로
    - 실행 파일의 위치(기준 경로)까지의 경로는 무시하고 나머지 경로만 넣어서 작성하는 방식
2. 절대 경로
    - 드라이브부터 거쳐오는 모든 경로를 작성하는 방식

따로 경로를 지정하지 않고 (파일명.확장자)로 작성하면 솔루션의 위치에 파일을 오픈합니다.
{: .notice--info}

마지막 인자는 `입출력 방식`입니다. 하나 혹은 두 문자를 입력하면 됩니다.

|문자|역할|
|---|---|
|w|파일을 만든다.|
|r|파일을 읽는다.|
|a|파일이 존재하면 파일을 열어<br>해당 파일 내용 뒤에 추가한다.<br>파일이 없으면 새로 만든다.|
|t|텍스트 파일|
|b|바이너리 파일|
|+|w+ : 파일이 있으면 읽고 쓰는 작업을 모두 한다.<br>없으면 새로 만든다.<br>r+ : 파일이 있으면 읽고 쓰는 작업을 모두 한다.<br>없으면 에러를 반환한다.<br>a+ : 파일이 있으면 파일을 맨 끝부터 읽고 쓴다.<br>파일이 없으면 새로 만든다.|

