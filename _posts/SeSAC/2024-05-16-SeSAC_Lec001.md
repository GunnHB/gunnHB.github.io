---
title:  "[SeSAC] 001. C++ 기본"
excerpt: "C++에 대해 알아봅시다!"

author: gunnHB
categories: 
 - SeSAC
tags: 
 - [Github, Git, Unreal, Programming, C++]

toc: true
toc_sticky: true
 
date: 2024-05-16
last_modified_at: 2024-05-16
---

🔔 새싹 언리얼엔진을 활용한 게임프로그래머 양성과정 강의를 듣고 정리한 내용입니다. 🔔
{: .notice}

## 시작 전

### 컴파일러
우리는 무언가를 동작시키기 위해 프로그래밍을 합니다. 우리가 작성하는 코드를 컴퓨터가 해석하여 결과를 보여주는 것입니다.
이러한 과정에서 코드의 내용을 컴퓨터가 이해할 수 있도록 번역을 담당하는 녀석이 있는데, 이를 `컴파일러compiler`라고 합니다.

컴파일러의 주된 역할은 프로그래밍 언어라고 불리는 <u>고수준의 언어</u>를 컴퓨터가 이해할 수 있는 <u>저수준의 언어</u>로 변환해주는 역할을 합니다.

### 프로젝트 생성
![image](https://github.com/GunnHB/gunnHB.github.io/assets/117302300/57867da6-8672-4214-b145-7959febfcbe3){: width="70%" height="70%"}{: .align-center}
우리가 처음 Visual Studio를 통해 프로젝트를 생성하면 `솔루션`이라는 것을 볼 수 있습니다. 이는 <u>여러 프로젝트를 담는 그릇</u>이라고 할 수 있습니다.

그리고 우리가 게임을 만들어 빌드하면 게임 실행파일 뿐 아니라 여러 파일이 생성되는 것을 확인할 수 있는데, 그 중 `dll` 파일을 확인할 수 있습니다.
dll 파일은 <u>라이브러리가 압축</u>된 내용을 뜻하며 안에는 코드 등의 내용들이 포함됩니다.

해당 비주얼 스튜디오는 한글 버전이지만 번역 등의 이슈가 있어 영어 버전의 사용을 권장합니다.
{: .notice--info}

### C++ 준비
![image](https://github.com/GunnHB/gunnHB.github.io/assets/117302300/90a4e171-4b2f-4932-9910-31923083e672){: width="70%" height="70%"}{: .align-center}
C++을 알아보기 위해 작성할 `소스 파일`을 생성해야 합니다. 소스 파일은 정직하게 <u>소스 파일 폴더</u> 아래에 생성하면 됩니다.

![image](https://github.com/GunnHB/gunnHB.github.io/assets/117302300/c7952394-be06-4289-bd8e-ab937720aa17){: width="70%" height="70%"}{: .align-center}
생성하게 되면 위와 같은 화면이 나옵니다. 여기서 `C++ 파일`을 선택하고 파일을 이름을 작성해주면 됩니다. 저는 `main.cpp`로 작성하였습니다.

파일 이름 작성 시 확장자명을 따로 적지 않아도 알아서 .cpp 파일로 생성합니다.
{: .notice--info}

여담으로 `헤더 파일`은 <u>특정 기능들을 모아놓은 파일</u>입니다. 이는 후에 자세히 작성하겠습니다.

## C++ 기본
이제 기본적인 내용을 작성해봅시다. 소스 파일에는 아무것도 작성되어 있지 않습니다. 프로그램의 동작을 위해

```c++
int main()
{
    return 0;
}
```

위 코드를 작성합시다. 이는 프로그램을 돌리기 위한 <u>기본적인 함수</u>입니다. 모든 소스는 엔트리 포인트가 필요합니다. <u>C++의 경우 main 함수</u>입니다.
프로그램을 동작시키면 컴파일러는 이 <u>main 함수를 기반</u>으로 해석을 시작하는데, 만약 main 함수가 여러개라면 어떤 함수를 먼저 시작해야하는지 몰라
이해하지 못합니다.

### 출력과 입력
출력과 입력의 테스트를 진행하기 위해서 우리는 <u>헤더 파일을 추가</u>해줘야 합니다.

```c++
#include <iostream>

int main()
{
    return 0;
}
```

`#include`는 해당하는 헤더 파일의 기능을 사용하겠다는 의미입니다. 우리는 입출력에 관련된 기능을 사용하고 싶기 때문에 <u>#include \<iostream></u>를 추가해주면 됩니다.

사용하려는 헤더 파일만 작성해줍시다.
{: .notice--warning}

```c++
#include <iostream>

int main()
{
    std::cout << "Hello World!" << std::endl;   // Hello World! 출력
    
    return 0;
}
```

위와 같이 코드를 작성해 실행시키면 `Hello World!`가 창에 출력되는 것을 확인할 수 있습니다. 실행문에서 `std::`는 `네임스페이스namespace` std의
기능을 사용하겠다는 의미입니다. `cout`은 출력 기능을 제공하고, `endl`은 실행문을 마친 후 개행하겠다는 의미입니다.

여기서 std::의 작성이 번거롭기에 main 함수 위에 `using namespace std;`를 추가해도 되지만 이는 지양하는 편이 좋습니다.
{: .notice--info}

```c++
#include <iostream>

int main()
{
    int input = 0;                      // 입력을 받기 위한 변수

    std::cin >> input;                  // 입력받고
    std::cout << input << std::endl;    // 입력받은 값을 출력
    
    return 0;
}
```

입력의 경우 `cin`을 사용합니다. cout과 반대로 >>를 작성해줍니다. 여기서 <<, >>는 `입출력 연산자`로 말그대로 입력과 출력을 위해 필요한 연산자입니다.

#### 이스케이프 시퀀스
문자열에 사용되는 특정 기능을 수행하는 특수문자들입니다.

|이스케이프 시퀀스|의미|
|---|---|
|\a|벨(경고)|
|\b|백스페이스|
|\f|폼 피드|
|\n|줄 바꿈|
|\r|캐리지 리턴|
|\t|가로 탭|
|\v|세로 탭|
|\'|작은 따옴표|
|\"|큰 따옴표|
|\\\ |역슬래시|
|\?|리터럴 물음표|

```c++
#include <iostream>

int main()
{
    std::cout << "Hellow World!"
    std::cout << "Hello World!\n"
    std::cout << "Hellow World!"

    // ** 결과 **
    // Hellow World!Hellow World!
    // Hellow World!

    return 0;
}
```

### 변수와 상수
변수와 상수는 <u>값을 저장할 수 있는 메모리 공간</u>을 의미합니다. 이를 이용하여 프로그램은 값을 저장해두었다가 필요할 때 사용하는 것입니다.

- `변수`
    - 변경이 가능한 데이터
    - 선언 시에 값을 할당해주지 않으면 쓰레기 값이 들어가게 된다.
- `상수`
    - 값이 고정된 데이터
    - 한번 할당된 값을 외부에서 수정할 수 없다.

C++에서 상수를 강제로 변경할 수 있는 기능을 제공하기는 하지만 사용하지 않는 것이 좋습니다.
{: .notice--info}

### 데이터 타입
변수를 선언할 때 변수가 사용할 데이터의 타입을 지정해줘야 합니다. 이러한 데이터 타입을 정리해보면 다음과 같습니다.

|타입|크기|종류|표현범위|
|---|---|---|---|
|char|1byte|문자|-128 ~ 127|
|short|2byte|정수|-32,768 ~ 32,767|
|int|4byte|정수|-2,147,483,648 ~ 2,147,483,647|
|_int64|8byte|정수|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807|
|float|4byte|실수|3.4E-38(-3.4 * 10<sup>38</sup>) ~ 3.4E+38(3.4 * 10<sup>38</sup>)|
|double|8byte|실수|1.79E-308(-1.79 * 10<sup>308</sup>) ~ 1.79E+308(1.79 * 10<sup>308</sup>)|
|bool|1byte|참 / 거짓|0 ~ 1|

여기서 추가로 `signned`와 `unsignned`가 존재하는데, 이는 <u>부호의 여부</u>입니다. 기본적으로 signned 타입이며,
타입 앞에 unsignned를 붙이면 unsignned 타입의 변수로 선언됩니다.

unsignned 타입의 경우 부호가 없기 때문에 표현범위 역시 0부터 시작하여 signned 타입 양의 정수 범위의 2배까지 가능합니다.
{: .notice--info}

전에는 8byte 정수형 타입으로 long형을 사용했는데 최근에는 _int64형을 사용합니다.
{: .notice--info}

#### 크기의 단위
bit < byte < kb < mb < gb < tb < ...

```c++
// 1byte == 8bit
// 1kb == 1024byte
// 1mb == 1024kb
// 1gb == 1024mb
// 1tb == 1024gb
```

#### 형변환
`형변환`은 작성하는 순간에만 변수의 타입을 변경하는 기능입니다. 이는 `암시적 형변환`과 `명시적 형변환`이 있습니다.

```c++
// 암시적 형변환
int number = 3.14f;     // 정수형 타입 변수에 실수를 할당하려 하면 암시적으로 정수를 할당한다.

// 명시적 형변환
float number2 = 0.1f;
number2 = (float)number // 실수형 타입에 정수형 변수를 할당하려고 할 때 [(데이터 타입)값] 형태로 할당해주면 원하는 데이터 타입의 값을 할당한다.
```

### 연산자
#### 사칙연산자
사칙연산자에는 우리가 실생활에서 사용하는 `+`, `-`, `*`, `/` 뿐만 아니라 `%(나머지 연산자)`를 추가로 있습니다.

- +
    - 덧셈에 사용되는 연산자
- -
    - 뺄셈에 사용되는 연산자
- *
    - 곱셈에 사용되는 연산자
- /
    - 나눗셈에 사용되는 연산자
    - 수와 수를 나누어 몫을 반환
- %
    - 나머지 연산에 사용되는 연산자
    - 수와 수를 나누어 나머지를 반환

덧셈과 뺄셈, 곱셈은 일반 사칙연산과 동일하여 괜찮지만 나눗셈과 나머지 연산은 익숙하지 않아 확인해볼 필요가 있습니다.

```c++
int main()
{
    std::cout << (10 / 3) << std::endl;         // 3 출력
    std::cout << (10 / 3) << std::endl;         // 1 출력
    std::cout << (10 / (float)3) << std::endl;  // 3.33333... 출력

    // 연산에 쓰인 괄호는 사용된 연산자가 사칙연산자임을 분명하게 해주기 위해 추가해줘야 합니다.
    // / 연산자의 경우 정수와 정수의 연산 시 정수의 결과를 반환합니다.
    // 만약 실수의 결과를 반환받고 싶다면 두 수 중 하나가 실수이면 됩니다.
}
```

#### 관계연산자
두 값을 비교할 때 사용하는 연산자입니다. 참과 거짓의 값을 반환합니다.

- <, >
    - 두 수의 크기 비교하여 참 / 거짓의 결과를 반환합니다. `미만`과 `초과`를 의미합니다.
- <=, >=
    - 마찬가지로 두 수의 크기를 비교하여 참 / 거짓을 반환합니다. `이상`과 `이하`를 의미합니다.
- ==
    - 두 값이 같은지 비교합니다. 같은면 참, 다르면 거짓입니다.
- !=
    - 두 값이 다른지 비교합니다. 같으면 거짓, 다르면 참입니다.

#### 논리연산자
`참`과 `거짓`의 두 값을 비교해 <u>참과 거짓의 결과를 반환</u>합니다. 종류에는 `&&(AND)`, `||(OR)`, `!(NOT)`이 있습니다.

|A|B|&&|\|\||
|---|---|---|---|
|0|0|0|0|
|1|0|0|1|
|0|1|0|1|
|1|1|1|1|

|A|!|
|---|---|
|0|1|
|1|0|

NOT연산(!)은 두 값을 비교하는 것이 아닌 값의 부정을 의미합니다.
{: .notice--info}

#### 증감연산자
값에 1을 더하거나 뺄 때 사용되는 연산자입니다. 값의 앞이나 뒤에 `++`, `--`를 붙여 사용할 수 있습니다.

```c++
int number = 0;

std::cout << number++ << std::endl; // 1 출력
```

이때 하나 알아둬야하는 것이 `전위연산`과 `후위연산`입니다. 전위연산은 <u>연산 후 기능을 수행</u>하고, 후위연산은 <u>기능을 수행 후에 연산</u>을 진행합니다. 

예를 들어

```c++
int number_f = 0;
int number_b = 0;

std::cout << ++number_f << std::endl; // 전위연산
std::cout << number_b++ << std::endl; // 후위연산
```

위와 같은 코드가 있을 때 출력은 `1`과 `0`이 출력되는 것을 알 수 있습니다. 이는 number_f의 경우 <u>연산이 먼저 되고 출력이 이루어져 1이 출력되는 것</u>이고,
number_b의 경우 <u>출력을 먼저 수행한 후 연산이 되는 것</u>입니다.

number_b의 경우 출력이 먼저 수행된 것입니다. 출력 이후 연산되었으므로 사실 number_b의 값은 1입니다.
{: .notice--info}

추가적으로 <u>사칙연산자 뒤</u>에 `=`을 붙여 사용하면 변수에 특정 값을 연산을 한 후 <u>재할당</u>한다는 의미입니다.

```c++
int number = 0;

number += 10;               // number 값에 10을 더한 후 값을 number에 할당한다.
// number = number + 10;    // 같은 의미. 이 코드를 축약한 것이라고 볼 수 있다.
```

#### 진수
우리는 10진법을 사용합니다. 하지만 컴퓨터는 2진법과 16진법을 선호합니다. 컴퓨터는 8개의 bit가 모인 byte 단위로 정보를 표현하는데,
2개의 16진수는 1byte의 2진수로 변환되기 때문에 정보를 표현하기 매우 유용한 이유 때문입니다.

이를 위해 10진수를 2진수와 16진수로 계산하는 방법을 알아봅시다.

계산에 사용되는 10진수 값은 375입니다.
{: .notice--info}

먼저 10진수에서 2진수로 변환하기 위해서는 값을 계속 2로 나누고 나머지를 기록합니다.

```c++
// 375 / 2 = 187...1
// 187 / 2 = 93...1
// 93 / 2 = 46...1
// 46 / 2 = 23...0
// 23 / 2 = 11...1
// 11 / 2 = 5...1
// 5 / 2 = 2...1
// 2 / 2 = 1...0
```

그리고 계산한 마지막으로 계산된 몫부터 나머지를 거꾸로 적어줍니다. 그렇게 결과값으로 <u>101110111</u>이 나옵니다.
이 값이 2진수로 표현된 375입니다.

이를 검산하려면 뒤에서부터 2<sup>0</sup>, 2<sup>1</sup>, 2<sup>2</sup>, ... ,2<sup>n-1</sup> 을 각 자리에 곱한 뒤 값을 모두 더해주면 됩니다.
{: .notice--info}

16진수로 변환하기 위해서는 먼저 구한 2진수를 뒤에서부터 4자리씩 끊어줍니다.

```c++
// 1 0111 0111
```

그리고 나온 값의 자리마다 2<sup>0</sup>부터 2<sup>3</sup>을 곱해 더해줍니다. 그렇게 되면 <u>177</u>의 결과가 나옵니다.

1 0111 0111의 경우 맨 앞의 1은 0001로 계산합니다.
{: .notice--info}

10진수의 177과 16진수의 177은 완전히 다른 값이므로 유의합시다.
{: .notice--warning}

#### 비트 단위 논리 연산자
비트 단위의 논리 연산자는 값과 값의 연산으로 값을 반환합니다. 종류로는 `&(AND)`, `|(OR)`, `^(XOR)`, `~(NOT)`이 있습니다.
이는 연산하는 값들을 2진수로 변환한 후 자리 마다의 논리연산을 수행하여 결과가 반환됩니다.

|A|B|&|\||^|
|---|---|---|---|---|
|0|0|0|0|0|
|1|0|0|1|1|
|0|1|0|1|1|
|1|1|1|1|0|

여기서 주목해야할 것이 XOR인데, 이는 같은 값이면 false를, 다른 값이면 true를 반환한다는 특징이 있습니다.
{: .notice--info}

만약 `375(101110111)`와 `584(1001001000)`의 값을 연산한다고 하면 다음과 같습니다.

```c++
// 375 & 584
//      101110111
//   & 1001001000
// --------------
//     0001000000

// 375 | 584
//      101110111
//   | 1001001000
// --------------
//     1101111111

// 375 | 584
//      101110111
//   ^ 1001001000
// --------------
//     1100111111

// ~375
//     ~101110111
// --------------
//      010001000
```

10진수의 계산보다 빠른 연산이 가능하여 사용됩니다.
{: .notice--info}

#### 시프트 연산자
비트를 왼쪽이나 오른쪽으로 밀어내 밀린 자리에는 0을 채웁니다. 종류로는 `>>`, `<<`이 있습니다. 만약 `10 << 2`라면
<u>10을 2진수로 변환하여 왼쪽으로 2칸 밀어내라</u>는 의미입니다.

```c++
// 10 << 2 -> 1010 << 2 -> 101000
// 결과 값을 10진수로 변환하면 40

// 10 << 3 -> 1010 << 3 -> 1010000
// 결과 값을 10진수로 변환하면 80
```

결과를 보면 일정한 규칙이 있는데, 사실 2<sup>n</sup>을 값에 곱한 것과 같은 값이 나옵니다.

```c++
// 10 >> 2 -> 1010 >> 2 -> 0010
// 결과 값을 10진수로 변환하면 2

// 10 >> 3 -> 1010 >> 3 -> 0001
// 결과 값을 10진수로 변환하면 1
```

반대의 경우에는 2<sup>n</sup>로 나누는 것과 같습니다.